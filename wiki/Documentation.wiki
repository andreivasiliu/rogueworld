#summary Documentaţie pentru Rogueworld

= Introducere =

Rogueworld  este rezultatul unei încercări de a rescrie o nouă variantă a unui "engine" pentru un joc din categoria Roguelike, un RPG  text în stilul lui NetHack. Privit într-o manieră superficială, un  „roguelike” este de fapt o expunere  bidimensională a unei lumi virtuale cu diferite caracteristici ce conferă posibilitatea explorării ei.


= Specificaţii =

  * Proiectul de faţă înglobează partea poate cea mai preteţioasă a unui astfel de "engine" şi anume cod specific comunicării pe reţea, diferenţiat pe trei nivele distincte, în care comunicarea se face înlănţuit ( primul strat, 1, comunică doar cu nivelul reţea şi stratul 2, stratul 2 comunică cu straturile 1 şi 3, stratul 3 comunică cu stratul 2, acesta fiind singurul la care funcţiile jocului au acces ).
  * Rogueworld poate fi continuat de orice doritor care deşi nu are suficiente cunoştiinţe despre programarea pe reţea poate continua nestigherit dezvoltarea unei noi lumi.
  * Trebuie remarcate la acest proiect structura şi claritatea codului. Toate funcţiile sunt descrise atât în server cât şi în client în două fişiere : `common.h`, respectiv `rwp_common.h`. Primul fişier header conţine toate funcţiile şi structurile necesare ce gestionează jucatori, evenimente, obiecte şi câteva operaţii de trimitere/primire de pachete. Funcţiile sunt grupate pe categorii şi sunt însoţite de un comentariu ce identifică fişierul sursă în care se află implementarea acestora. Fisierul `rwp_common.h` conţine diferite macro-uri, dar şi funcţii speciale de citire şi scriere a căror implementare se gaseşte in `rwp_common.c`.
  * Serverul poate deservi mai mulţi clienţi în acelaşi timp indiferent de opţiunea aleasă de client; acesta are posibilitatea să aleagă o conexiune TCP sau una UDP în funcţie de preferinţe, cunoscând însă ce implică alegerea fiecăreia dintre ele.

= Detalii =

În această secţiune vom detalia anumite aspecte din implementare. 

== Comunicarea la nivelul serverului. ==

  * `main_loop()`
    * `init_udp_server()`
        * această funcţie creează un nou socket şi ascultă pe el eventualii clienţi UDP cu scopul de a adăuga noi clienţi în lista de conexiuni sau de a primi pachete pentru clienţii deja conectaţi;
    * `init_tcp_server()`
        * această funcţie creează un nou socket şi ascultă pe el eventualii clienţi TCP cu acelaţi scop ca mai sus; 
    * `while()`
      * creează o nouă mulţime de sockets pentru verificare;
      * se apelează `select()` pe mulţimea construită;
      * verifică:
        * dacă există un nou client UDP apelează: `new_udp_connection()` - această funcţie adaugă noua conexiune UDP în lista existentă şi îi asociază un port remote;
        * dacă există un nou client TCP apelează: `new_tcp_connection()` - această funcţie adaugă noua conexiune TCP în lista existentă şi îi asociază un port remote;
        * dacă a sosit un nou pachet apelează `read_data()` - această funcţie citeste                        orice fel de pachet;



== Retrimiterea pachetelor. ==

  * `struct packet_header`
        *`{`
            *`int length;`
            *`int msg_id;`
            *`int msg_nr;`
            *`int obj_id;`
            *`int obj_nr;`
        *`};`

  *  Acest al doilea strat primeste un pachet construit de cel de-al treilea strat şi îl trimite într-o coadă. Când primeşte un pachet MSG_CONFIRM<nr>, şterge toate pachetele până la acel număr şi retrimite toate pachetele cu un număr mai mare, dar numai câte un pachet pentru fiecare obj_id ( cel cu obj_nr cel mai mare ), dacă obj_id nu este 0.


== Construcţia pachetelor ==

  * Function